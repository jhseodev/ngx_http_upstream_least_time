diff --git a/src/event/ngx_event_connect.h b/src/event/ngx_event_connect.h
index d3b23782..e6baf978 100644
--- a/src/event/ngx_event_connect.h
+++ b/src/event/ngx_event_connect.h
@@ -47,6 +47,14 @@ struct ngx_peer_connection_s {
     ngx_event_free_peer_pt           free;
     ngx_event_notify_peer_pt         notify;
     void                            *data;
+    void                            *peer;
+    ngx_msec_t                       response_time;
+    ngx_msec_t                       header_time;
+
+    ngx_atomic_t                    *average_response_time;
+    ngx_atomic_t                    *current_response_time;
+    ngx_atomic_t                    *average_header_time;
+    ngx_atomic_t                    *current_header_time;
 
 #if (NGX_SSL || NGX_COMPAT)
     ngx_event_set_peer_session_pt    set_session;
diff --git a/src/http/ngx_http_upstream.c b/src/http/ngx_http_upstream.c
index 92582436..f21f91a9 100644
--- a/src/http/ngx_http_upstream.c
+++ b/src/http/ngx_http_upstream.c
@@ -4302,6 +4302,7 @@ ngx_http_upstream_finalize_request(ngx_http_request_t *r,
     ngx_http_upstream_t *u, ngx_int_t rc)
 {
     ngx_uint_t  flush;
+    ngx_msec_t  average_response_time=1, average_header_time=1;
 
     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                    "finalize http upstream request: %i", rc);
@@ -4322,6 +4323,13 @@ ngx_http_upstream_finalize_request(ngx_http_request_t *r,
 
     if (u->state && u->state->response_time == (ngx_msec_t) -1) {
         u->state->response_time = ngx_current_msec - u->start_time;
+        u->peer.response_time = u->state->response_time;
+        if (u->peer.response_time == 0) {
+            u->peer.response_time += 1;
+        }
+        if (u->peer.header_time == 0 && u->state->bytes_received == 0) {
+            u->peer.header_time = u->peer.response_time;
+        }
 
         if (u->pipe && u->pipe->read_length) {
             u->state->bytes_received += u->pipe->read_length
@@ -4337,6 +4345,28 @@ ngx_http_upstream_finalize_request(ngx_http_request_t *r,
     u->finalize_request(r, rc);
 
     if (u->peer.free && u->peer.sockaddr) {
+        if (u->peer.connection) {
+            if (*u->peer.current_response_time > 0) {
+                average_response_time = (u->peer.response_time * 3 +
+                        *u->peer.average_response_time) / 4;
+            } else {
+                average_response_time = u->peer.response_time;
+            }
+
+            if (*u->peer.current_header_time > 0) {
+                average_header_time = (u->peer.header_time * 3 +
+                        *u->peer.average_header_time) / 4;
+            } else {
+                average_header_time = u->peer.header_time;
+            }
+
+            *u->peer.current_response_time = u->peer.response_time;
+            *u->peer.current_header_time = u->peer.header_time;
+            *u->peer.average_header_time = average_header_time;
+            *u->peer.average_response_time = average_response_time;
+            ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0, "crt:%i", *u->peer.current_response_time);
+        }
+
         u->peer.free(&u->peer, u->peer.data, 0);
         u->peer.sockaddr = NULL;
     }
diff --git a/src/http/ngx_http_upstream_round_robin.c b/src/http/ngx_http_upstream_round_robin.c
index f72de3ee..a0dd6650 100644
--- a/src/http/ngx_http_upstream_round_robin.c
+++ b/src/http/ngx_http_upstream_round_robin.c
@@ -37,6 +37,12 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
     ngx_http_upstream_rr_peer_t   *peer, **peerp;
     ngx_http_upstream_rr_peers_t  *peers, *backup;
 
+    u_char              *shared;
+    size_t               size, cl;
+    ngx_shm_t            shm;
+
+    cl = 128;
+
     us->peer.init = ngx_http_upstream_init_round_robin_peer;
 
     if (us->servers) {
@@ -71,6 +77,17 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
             return NGX_ERROR;
         }
 
+        size = n * cl;
+        shm.size = size;
+        ngx_str_set(&shm.name, "nginx_upstream_peer_least_time");
+        shm.log = cf->log;
+
+        if (ngx_shm_alloc(&shm) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        shared = shm.addr;
+
         peers->single = (n == 1);
         peers->number = n;
         peers->weighted = (w != n);
@@ -97,6 +114,10 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
                 peer[n].fail_timeout = server[i].fail_timeout;
                 peer[n].down = server[i].down;
                 peer[n].server = server[i].name;
+                peer[n].current_response_time = (ngx_atomic_t *) shared + n * 4;
+                peer[n].current_header_time = (ngx_atomic_t *) shared + n * 4 + 1;
+                peer[n].average_response_time = (ngx_atomic_t *) shared + n * 4 + 2;
+                peer[n].average_header_time = (ngx_atomic_t *) shared + n * 4 + 3;
 
                 *peerp = &peer[n];
                 peerp = &peer[n].next;
@@ -134,6 +155,17 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
             return NGX_ERROR;
         }
 
+        size = n * cl;
+        shm.size = size;
+        ngx_str_set(&shm.name, "nginx_upstream_peer_least_time");
+        shm.log = cf->log;
+
+        if (ngx_shm_alloc(&shm) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        shared = shm.addr;
+
         peers->single = 0;
         backup->single = 0;
         backup->number = n;
@@ -161,6 +193,10 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
                 peer[n].fail_timeout = server[i].fail_timeout;
                 peer[n].down = server[i].down;
                 peer[n].server = server[i].name;
+                peer[n].current_response_time = (ngx_atomic_t *) shared + n * 4;
+                peer[n].current_header_time = (ngx_atomic_t *) shared + n * 4 + 1;
+                peer[n].average_response_time = (ngx_atomic_t *) shared + n * 4 + 2;
+                peer[n].average_header_time = (ngx_atomic_t *) shared + n * 4 + 3;
 
                 *peerp = &peer[n];
                 peerp = &peer[n].next;
@@ -466,6 +502,11 @@ ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)
 
     peer->conns++;
 
+    pc->average_header_time = peer->average_header_time;
+    pc->average_response_time = peer->average_response_time;
+    pc->current_header_time = peer->current_header_time;
+    pc->current_response_time = peer->current_response_time;
+
     ngx_http_upstream_rr_peers_unlock(peers);
 
     return NGX_OK;
@@ -496,6 +537,11 @@ failed:
         ngx_http_upstream_rr_peers_wlock(peers);
     }
 
+    pc->average_header_time = peer->average_header_time;
+    pc->average_response_time = peer->average_response_time;
+    pc->current_header_time = peer->current_header_time;
+    pc->current_response_time = peer->current_response_time;
+
     ngx_http_upstream_rr_peers_unlock(peers);
 
     pc->name = peers->name;
diff --git a/src/http/ngx_http_upstream_round_robin.h b/src/http/ngx_http_upstream_round_robin.h
index 45f258d2..3eeeff29 100644
--- a/src/http/ngx_http_upstream_round_robin.h
+++ b/src/http/ngx_http_upstream_round_robin.h
@@ -49,6 +49,13 @@ struct ngx_http_upstream_rr_peer_s {
     ngx_atomic_t                    lock;
 #endif
 
+    ngx_atomic_t                   *least_time;
+
+    ngx_atomic_t                   *current_response_time;
+    ngx_atomic_t                   *current_header_time;
+    ngx_atomic_t                   *average_response_time;
+    ngx_atomic_t                   *average_header_time;
+
     ngx_http_upstream_rr_peer_t    *next;
 
     NGX_COMPAT_BEGIN(32)
@@ -60,6 +67,7 @@ typedef struct ngx_http_upstream_rr_peers_s  ngx_http_upstream_rr_peers_t;
 
 struct ngx_http_upstream_rr_peers_s {
     ngx_uint_t                      number;
+    ngx_flag_t                      first_request;
 
 #if (NGX_HTTP_UPSTREAM_ZONE)
     ngx_slab_pool_t                *shpool;
